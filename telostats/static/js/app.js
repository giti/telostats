// Generated by CoffeeScript 1.3.3
(function() {
  var MARKER_BUCKET_COLORS, TELOSTATS_TILEJSON, initMap, pushStateNav, renderStationMap, stationClassifier, stationsLayer;

  TELOSTATS_TILEJSON = {
    'tilejson': '2.0.0',
    'scheme': 'xyz',
    'name': 'Tel Aviv Light',
    'description': 'A light tileset focusing on the municipality of Tel Aviv, suitable for visualizations.',
    'attribution': 'OSM contributors',
    'bounds': [34.742, 32.026, 34.924, 32.149],
    'minzoom': 13,
    'maxzoom': 17,
    'tiles': [TILESERVER_URL],
    'grids': []
  };

  MARKER_BUCKET_COLORS = {
    0: '#dd2ea3',
    1: '#ffafe5',
    2: '#ccc',
    3: '#94e1ff',
    4: '#18b4f1'
  };

  stationClassifier = function(poles, available) {
    var bikes;
    bikes = poles - available;
    if (bikes === 0) {
      return 0;
    } else if (bikes <= 5) {
      return 1;
    } else if (available <= 5) {
      return 3;
    } else if (available === 0) {
      return 4;
    } else {
      return 2;
    }
  };

  renderStationMap = function(elem) {
    var baseLayer, bucket, coords, id, markerLayer, stationmap;
    id = $(elem).attr('data-id');
    coords = {
      lat: Number($(elem).attr('data-lat')),
      lon: Number($(elem).attr('data-lon'))
    };
    bucket = stationClassifier($(elem).attr('data-poles'), $(elem).attr('data-available'));
    baseLayer = mapbox.layer().tilejson(TELOSTATS_TILEJSON);
    markerLayer = mapbox.markers.layer();
    markerLayer.add_feature({
      geometry: {
        type: "Point",
        coordinates: [coords.lon, coords.lat]
      }
    }).factory(function(f) {
      var marker;
      marker = ich.stationmarker_svg_template({
        bucket: bucket
      });
      return marker[0];
    });
    stationmap = mapbox.map(elem, [], null, []);
    stationmap.addLayer(baseLayer);
    stationmap.addLayer(markerLayer);
    return stationmap.centerzoom(coords, 17, false);
  };

  stationsLayer = function(opts) {
    var animationDelayTime, draw, drawStations, fadeInTime, layer, map, project, registerMapMouseDragHandlers, s, stationAnimation, stationAnimationWait, stationCoords, stationData, stationDotSize, stations, svg;
    map = opts.map;
    stationData = opts.stations;
    stationCoords = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stationData.length; _i < _len; _i++) {
        s = stationData[_i];
        _results.push([s.longitude, s.latitude]);
      }
      return _results;
    })();
    svg = d3.select(document.body).append('svg').attr('id', 'd3svg');
    stations = svg.append('g').attr('id', 'stations');
    fadeInTime = 500;
    animationDelayTime = 600;
    stationDotSize = d3.scale.quantize().domain([opts.minZoom, opts.maxZoom]).range([2, 3, 4]);
    stationAnimation = d3.scale.linear().domain(d3.extent(stationCoords, function(coord) {
      return coord[1];
    })).range([0, fadeInTime]);
    project = function(location) {
      var point;
      point = map.locationPoint({
        lat: location[1],
        lon: location[0]
      });
      return [point.x, point.y];
    };
    stationAnimationWait = function(index) {
      return stationAnimation(stationData[index].latitude);
    };
    registerMapMouseDragHandlers = function(elem) {
      var clientX, clientY, d3elem, stationid;
      d3elem = d3.select(elem);
      stationid = d3elem.attr('data-id');
      d3elem.classed('loading', false);
      clientX = null;
      clientY = null;
      d3elem.on('mousedown', function(d, i) {
        clientX = d3.event.clientX;
        return clientY = d3.event.clientY;
      });
      return d3elem.on('mouseup', function(d, i) {
        var newflyout, stationary;
        stationary = clientX === d3.event.clientX && clientY === d3.event.clientY;
        if (d3elem.classed('selected')) {
          return;
        }
        if (stationary) {
          d3.selectAll('.station').classed('selected', false);
          newflyout = ich.stationflyout_template({
            stationid: stationid
          });
          $('#stationflyouts').append(newflyout);
          opts = {
            url: '/station/' + stationid,
            container: ".stationflyout[data-id=" + stationid + "]"
          };
          d3elem.classed('selected', true);
          $.pjax(opts);
          return $(newflyout).on('pjax:end', function() {
            var mapelem;
            mapelem = $(".station-map[data-id='" + stationid + "']")[0];
            renderStationMap(mapelem);
            $(this).removeClass('hidden');
            return setTimeout(function() {
              $('.flyout.secondary:not(.stationflyout)').addClass('hidden');
              return $(".stationflyout[data-id!=" + stationid + "]").remove();
            }, 200);
          });
        }
      });
    };
    drawStations = function() {
      var cellGroups, cellsEnter, dots, dotsEnter, groupsEnter, stationDelay;
      stationDelay = function(d, i) {
        return animationDelayTime + fadeInTime - stationAnimationWait(i);
      };
      cellGroups = stations.selectAll('g').data(stationData);
      groupsEnter = cellGroups.enter().append('g');
      cellsEnter = groupsEnter.append('path');
      dotsEnter = groupsEnter.append('circle');
      dots = stations.selectAll('g>circle').data(stationData);
      dots.attr('r', stationDotSize(map.zoom())).attr('transform', function(d) {
        return 'translate(' + project([d.longitude, d.latitude]) + ')';
      });
      groupsEnter.classed('station', true).classed('loading', true).attr('data-id', function(d, i) {
        return stationData[i].id;
      }).attr('data-lat', function(d, i) {
        return stationData[i].latitude;
      }).attr('data-lon', function(d, i) {
        return stationData[i].longitude;
      }).attr('data-bucket', function(d, i) {
        return stationClassifier(stationData[i].poles, stationData[i].available);
      }).attr('data-poles', function(d, i) {
        return stationData[i].poles;
      }).attr('data-available', function(d, i) {
        return stationData[i].available;
      }).transition().delay(stationDelay).duration(200).each('end', function() {
        return registerMapMouseDragHandlers(this);
      });
      cellsEnter.classed('station_cell', true);
      dotsEnter.classed("station_dot", true).attr('opacity', 0.0).attr('r', 0).attr('transform', function(d) {
        return 'translate(' + project([d.longitude, d.latitude]) + ')';
      }).transition().delay(150).duration(450).attr('opacity', 0.15).attr('r', 8 * stationDotSize(map.zoom())).transition().delay(stationDelay).duration(200).attr('r', stationDotSize(map.zoom())).attr('opacity', 1);
      return stations.selectAll('g>path').data(stationData).attr('d', function(d, i) {
        var p, poly, projected;
        poly = d3.geom.polygon(stationData[i].polygon);
        projected = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = poly.length; _i < _len; _i++) {
            p = poly[_i];
            _results.push(project(p));
          }
          return _results;
        })();
        return 'M' + projected.join('L') + 'Z';
      });
    };
    draw = function() {
      svg.attr('width', $('#map').width()).attr('height', $('#map').height());
      return drawStations();
    };
    layer = {
      'project': project,
      'draw': draw,
      'parent': svg.node()
    };
    return layer;
  };

  initMap = function() {
    var m, mapbounds, maxZoom, minZoom;
    m = mapbox.map('map');
    minZoom = 13;
    maxZoom = 17;
    m.addLayer(mapbox.layer().tilejson(TELOSTATS_TILEJSON));
    m.ui.zoomer.add();
    mapbounds = new MM.Extent(32.149, 34.742, 32.026, 34.924);
    m.setExtent(mapbounds);
    m.setPanLimits(mapbounds);
    m.setZoomRange(minZoom, maxZoom);
    return d3.json('/api/v1/station/', function(stations) {
      var opts, sl;
      opts = {
        'map': m,
        'stations': stations.objects,
        'minZoom': minZoom,
        'maxZoom': maxZoom
      };
      sl = stationsLayer(opts);
      return m.addLayer(sl);
    });
  };

  pushStateNav = function(url) {
    window.history.pushState(null, '', url);
    if (typeof _gaq !== "undefined" && _gaq !== null) {
      return _gaq.push(['_trackPageview', url]);
    }
  };

  $(function() {
    initMap();
    _.each($(".station-map"), renderStationMap);
    $(document).pjax('a[data-pjax]');
    $('.close-flyout').live('click', function(e) {
      $(this).parent().addClass('hidden');
      d3.select('.selected').classed('selected', false);
      pushStateNav($(this).attr('href'));
      return false;
    });
    return $('a.static-flyout').click(function() {
      var target;
      target = $(this).attr('data-flyout');
      $(target).removeClass('hidden');
      pushStateNav($(this).attr('href'));
      return false;
    });
  });

}).call(this);
